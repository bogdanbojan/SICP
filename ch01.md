## Building Abstractions with Procedures

### The Elements of Programming

- **Primitive expressions**, which represent the simplest entities the lan­
guage is concerned with,
- **Means of combination**, by which compound elements are built from
simpler ones, and
- **Means of abstraction**, by which compound elements can be named
and manipulated as units.

---

### Expressions

You type an *expression*, and the interpreter responds by displaying the result 
of its *evaluating* that expression.

Advantages of *prefix notation*: 
- Takes an arbitrary number of arguments
- Allows combinations to be *nested* (therefore, having no limit (in theory) to 
the nesting and overall complexity of the expressions) 

```
(+ 137 349)
486
```

More complex expresisons can be formatted as such:

```
(+ (* 3
        (+ (* 2 4)
            (+ 3 5 ) ) )
    (+ ( - 1 0 7)
        6) )
```

---

### Naming and Environment

The name identifies a *variable* whose *value* is the object.

In Scheme, we use `define`. This being the language's simplest means of abstraction.

Incremental development by using name-object associations.

```
(define pi 3 . 1 4 1 59)
(define radius 1 0 )
(* p i (* radius radius ) )
314.159
```

The interpreter must maintain some sort of memory that keeps track of the 
name-object pairs. This memory is called the *environment* (more precisely the 
*global environment*.

---

### Evaluating Combinations

Thinking procedurally, when evaluating a combination:

1. Evaluate the subexpressions of the combination.
2. Apply the procedure that is the value of the leftmost subexpression
(the operator) to the arguments that are the values of the other subex­
pressions (the operands

The expression is *recursive* in nature:

```
(* (+2 (*4 6))
    (+ 3 5 7))
```

![](./ch01/tree-calculation.png)

---

The "percolate values upward" form of the evaluation is an example of a general 
kind of process known as *tree accumulation*.

It is interesting to note that symbols such as `+` or `*` are also included in 
the global environment, and are associated with the sequences of machine instructions
that are their "values".

*Special forms* are exceptions to the general evaluation rules. For instance, 
evaluating `define x 3` does not apply `define` to two arguments. The purpose 
of `define` is to associate `x` with a value (That is, `define x 3` is not a 
combination.)
- Each special form has its associated evaluation rule
- The various kinds of expressions (each with its associated evaluation rule),
constitute the syntax of the programming languge

---

### Compound Procedures

We identified:
- Numbers and arithmetic operations are primitive data and procedures.
- Nesting of combinations provides a means of combining operations.
- Definitions that associate names with values provide a limited means
of abstraction.

---

*Procedure definitions*

A *compound procedure*, which has been given the name `square`: 
```
(define (square x) (* x x))
```
The general form of a procedure definition is:
```
(define (<name> <formal parameters>) <body>)
```

The `<name>` and `<formal parameters>` are grouped within parantheses, just as 
they would be in an actual call to the procedure being defined.

Further compounding enables us to do things like:
```
(define (sum-of-squares x y)
    (+ (square x) (square y)))

(sum-of-squares 3 4 )
25
```

---

*The substitution model*

The process is reducing expressions for procedure application. 

\* The way an interpreter works is more nuanced. Especially when we are talking 
about mutable data..

```
(f 5) 

(sum-of-squares (+ a 1) (* a 2))

(sum-of-squares (+ 5 1) (* 5 2))

(+ (square 6) (square 10))

(+ (6 6) (10 10))

(+ 36 100)

136
```

---

**Applicative order vs normal order**

- Evaluate the operator and operands and then apply the resulting procedure to 
the resulting arguments

vs

- Don't evaluate the operands until their values are needed. First substitute
operand expressions for parameters until you obrain an expression involving 
only primitive operators,  and then perform the evaluation

```
(f 5) 

(sum-of-squares (+ 5 1) (* 5 2))

(+ (square (+ 5 1)) (square (* 5 2)))

(+ (* (+ 5 1) (+ 5 1)) (* (* 5 2)(* 5 2)))

(+ (* 6 6) (* 10 10))

(+ 36 100)

136
```

This is called *normal-order evaluation* which is in contrast to the method
that the interpreter actually uses, which is called *applicative-order evaluation*.

---

### Conditional Expressions and Predicates

*Case analysis*
In Lisp we use it with `cond`.

The general form would be:

```
(cond (<p1> <e1>)
      (<p1> <e1>)
      .
      .
      .
      (<p1> <e1>)
```

Where: 
- (\<p> \<e>) = clause
- `<p>`       = predicate  
- `<e>`       = consequent expression.
- else        = fallback

You can write absolute-value procedures in different ways:

```
(define (abs x)
    (cond ((> x 0) x)
          ((= x 0) 0) 
          ((< x 0) (- x))))

---

(define (abs x)
    (cond ((< x 0) (- x))
          (else x)))

---

(define (abs x)
    (if (< x 0)
        (- x)
        x))
```

Essentially, they all follow:

(if <*predicate*> <*consequent*> <*alternative*>)

---

There are also logical composition operations that enable us to construct 
compound predicates. For example:

- (`and` <*e1*> ... <*en*>)
- (`or`  <*e1*> ... <*en*>)
- (`not` <*e*>)

\* `and` and `or` are special forms, not procedures, because the subexpressions 
are not necessarily all evaluated. `Not` is an ordinary procedure.
